<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quiz</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { background: #f8f9fa; }
        .option-card { cursor: pointer; }
        .option-selected { border: 2px solid #0d6efd; background: #e7f1ff; }
        .option-correct { border: 2px solid #198754; background: #e9f7ee; }
        .option-wrong { border: 2px solid #dc3545; background: #fdecea; opacity: .95; }
        .small-muted { font-size: .85rem; color: #58616a; }
        .warn-pill { background: #fff3cd; border: 1px solid #ffecb5; padding: 6px 10px; border-radius: 20px; color: #856404; }
    </style>
</head>

<body>
<div class="container py-4" id="app">

    <div class="d-flex justify-content-between mb-4">
        <h2>[[ category ]]</h2>
        <div>
            <a href="{% url 'profile' %}" class="btn btn-secondary btn-sm me-2">Profile</a>
            <a href="{% url 'scores' %}" class="btn btn-primary btn-sm me-2">My Scores</a>
            <a href="{% url 'logout' %}" class="btn btn-danger btn-sm">Logout</a>
        </div>
    </div>

    <div v-if="loading" class="text-center py-5">
        <div class="spinner-border text-primary"></div>
        <div class="mt-2 small-muted">Loading questions...</div>
    </div>

    <div v-else>

        <div class="d-flex justify-content-between mb-3">
            <div>
                <div class="small-muted">Question [[ currentIndex + 1 ]] of [[ questions.length ]]</div>
                <h5>[[ currentQuestion.question ]]</h5>
            </div>
            <div class="text-end">
                <div class="small-muted">Score: [[ score ]] / [[ totalMarks ]]</div>
                <div v-if="warningMessage" class="warn-pill mt-1">[[ warningMessage ]]</div>
                <div class="small-muted mt-1">Warnings: [[ warnings ]]</div>
            </div>
        </div>

        <div class="row g-2 mb-4">
            <div class="col-12"
                 v-for="(ans, idx) in currentQuestion.answers"
                 :key="currentQuestion.uid + '_' + idx">

                <div class="p-3 rounded border option-card"
                     :class="optionClass(currentQuestion.uid, ans)"
                     @click="selectAnswer(currentQuestion.uid, ans.uid)">

                    <div class="form-check">
                        <input type="radio"
                               class="form-check-input"
                               :name="'q_' + currentQuestion.uid"
                               :id="'ans_'+idx"
                               :value="ans.uid"
                               v-model="currentQuestion.selected">

                        <label class="form-check-label ms-2" :for="'ans_' + idx">
                            [[ ans.answer ]]
                        </label>
                    </div>
                </div>
            </div>
        </div>

        <div class="d-flex justify-content-between">
            <button class="btn btn-secondary" @click="previousQuestion" :disabled="currentIndex===0">Previous</button>

            <div>
                <button class="btn btn-warning me-2" @click="regenerate" :disabled="regenLoading">
                    <span v-if="regenLoading" class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                    Regenerate
                </button>
                <button class="btn btn-primary me-2" @click="nextQuestion" :disabled="currentIndex===questions.length-1">Next</button>
                <button class="btn btn-success" v-if="currentIndex===questions.length-1 && !submitted" @click="submitQuiz">Submit</button>
            </div>
        </div>

        <div class="card p-3 mt-4">
            <div class="small-muted mb-2">Session Monitor</div>
            <div>Tab switches: [[ tabSwitches ]]</div>
            <div>Window blur: [[ blurCount ]]</div>
            <div>Warnings: [[ warnings ]]</div>

            <div class="mt-3">
                <button class="btn btn-danger btn-sm me-2" @click="forceSubmit">Force Submit</button>
                <button class="btn btn-secondary btn-sm" @click="resetWarnings">Reset</button>
            </div>
        </div>

        <div v-if="submitted" class="alert alert-info mt-4">
            Submitted. Score: [[ score ]] / [[ totalMarks ]]
        </div>

    </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>

<script>
function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const c = cookies[i].trim();
            if (c.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(c.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}


new Vue({
    el: "#app",
    delimiters: ["[[", "]]"],

    data() {
        return {
            category: "{{ category|escapejs }}",
            level: "{{ level|default:'medium'|escapejs }}",

            questions: [],
            currentIndex: 0,
            score: 0,
            totalMarks: 0,
            submitted: false,
            loading: true,

            regenLoading: false,

            warnings: 0,
            tabSwitches: 0,
            blurCount: 0,
            warningMessage: "",
            autoSubmitting: false
        }
    },

    computed: {
        currentQuestion() {
            if (!this.questions.length) return { answers: [] };
            return this.questions[this.currentIndex];
        }
    },

    methods: {
        async loadQuestions() {
            this.loading = true;
            try {
                const r = await fetch(`/api/get-quiz/?category=${this.category}&count=10`);
                const j = await r.json();
                if (j.status) {
                    this.questions = j.data.map(q => {
                        q.selected = null;
                        q.attempted = false;
                        return q;
                    });
                    this.totalMarks = this.questions.reduce((s, q) => s + (q.marks || 0), 0);
                }
            } catch (e) {
                console.error("Load questions error:", e);
            }
            this.loading = false;
        },

        selectAnswer(qid, ansid) {
            const q = this.questions.find(x => x.uid === qid);
            if (!q) return;
            q.selected = ansid;
            q.attempted = true;
            this.updateScore();
        },

        optionClass(qid, ans) {
            const q = this.questions.find(x => x.uid === qid);
            if (!q || !q.attempted) return "";

            if (String(q.selected) === String(ans.uid)) {
                return ans.is_correct ? "option-correct" : "option-wrong";
            }

            return ans.is_correct ? "option-correct" : "";
        },

        nextQuestion() {
            if (this.currentIndex < this.questions.length - 1) this.currentIndex++;
        },

        previousQuestion() {
            if (this.currentIndex > 0) this.currentIndex--;
        },

        updateScore() {
            let s = 0;
            for (const q of this.questions) {
                const ans = q.answers.find(a => String(a.uid) === String(q.selected));
                if (ans && ans.is_correct) s += q.marks;
            }
            this.score = s;
        },

        async regenerate() {
            if (this.regenLoading) return;
            this.regenLoading = true;
            this.warningMessage = "Generating new questions...";

            try {
                const res = await fetch("/generate-questions/", {
                    method: "POST",
                    credentials: "same-origin",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCookie("csrftoken")
                    },
                    body: JSON.stringify({
                        category: this.category,
                        difficulty: this.level || "medium",
                        count: 10
                    })
                });

                if (!res.ok) {
                    const txt = await res.text().catch(() => "");
                    throw new Error("HTTP " + res.status + ": " + txt);
                }

                const data = await res.json().catch(() => null);

                if (!data || !data.questions || !data.questions.length) {
                    throw new Error("AI returned empty or invalid data");
                }

                this.loadQuestionsToUI(data.questions);
                this.currentIndex = 0;
                this.warningMessage = "New questions loaded";
            }
            catch (e) {
                alert("Regenerate failed: " + (e.message || e));
                console.error("Regenerate error:", e);
            }
            finally {
                this.regenLoading = false;
            }
        },

        loadQuestionsToUI(qs) {
            this.questions = qs.map((q, idx) => {
                const options = q.options || q.answers || [];

                return {
                    uid: q.uid || ("ai_" + idx),
                    question: q.question || "New Question",
                    marks: q.marks || 1,
                    answers: options.map((o, i) => ({
                        uid: i,
                        answer: o,
                        is_correct: (o === q.correct)
                    })),
                    selected: null,
                    attempted: false
                };
            });

            this.totalMarks = this.questions.reduce((s, q) => s + q.marks, 0);
            this.updateScore();
        },


        async submitQuiz() {
            if (this.submitted) return;

            this.updateScore();

            try {
                await fetch("/api/save-result/", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "X-CSRFToken": getCookie("csrftoken")
                    },
                    body: JSON.stringify({
                        score: this.score,
                        total_marks: this.totalMarks,
                        category: this.category
                    })
                });
            } catch (e) {
                console.error("Submit error:", e);
            }

            this.submitted = true;
        },

        forceSubmit() {
            this.submitQuiz();
        },

        resetWarnings() {
            this.warnings = 0;
            this.tabSwitches = 0;
            this.blurCount = 0;
            this.warningMessage = "";
        },

        autoSubmit(reason) {
            if (this.autoSubmitting) return;
            this.autoSubmitting = true;
            this.warningMessage = "Auto-submitting: " + reason;
            setTimeout(() => this.submitQuiz(), 600);
        }
    },

    mounted() {
        this.loadQuestions();

        document.addEventListener("visibilitychange", () => {
            if (document.hidden) {
                this.tabSwitches++;
                this.warnings++;
                this.warningMessage = "Tab switched";
                if (this.warnings >= 3) this.autoSubmit("Multiple tab switches");
            }
        });

        window.addEventListener("blur", () => {
            this.blurCount++;
            this.warnings++;
            this.warningMessage = "Window unfocused";
            if (this.warnings >= 3) this.autoSubmit("Window blur repeated");
        });

        window.addEventListener("focus", () => {
            if (this.warningMessage === "Window unfocused") {
                this.warningMessage = "";
            }
        });
    }
});
</script>

</body>
</html>
